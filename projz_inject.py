# Copyright 2004-2021 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file is modified by https://github.com/abse4411
from __future__ import division, absolute_import, with_statement, print_function, unicode_literals

import os
import shutil
import time

from renpy.compat import *

import renpy.translation
import json
import collections
from renpy.translation import quote_unicode
from renpy.parser import elide_filename
from renpy.translation.generation import translate_list_files, translation_filename, shorten_filename, rot13_filter, \
    piglatin_filter, null_filter
from copy import copy

projz_banner = '''##########################################################
#  ________  ________  ________        ___  ________     #
# |\   __  \|\   __  \|\   __  \      |\  \|\_____  \    #
# \ \  \|\  \ \  \|\  \ \  \|\  \     \ \  \\\\|___/  /|   #
#  \ \   ____\ \   _  _\ \  \\\\\  \  __ \ \  \   /  / /   #
#   \ \  \___|\ \  \\\\  \\\\ \  \\\\\  \|\  \\\\_\  \ /  /_/__  #
#    \ \__\    \ \__\\\\ _\\\\ \_______\ \________\\\\________\\#
#     \|__|     \|__|\|__|\|_______|\|________|\|_______|#
#                                                        #
#  This ryp file is generated by the project:            #
#  https://github.com/abse4411/projz_renpy_translation   #
##########################################################'''

def item_of(
        identifier=None,
        language=None,
        what=None,
        new_text=None,
        who=None,
        filename=None,
        linenumber=None,
):
    return {
        'identifier': identifier,
        'language': language,
        'what': what,
        'new_text': new_text,
        'who': who,
        'filename': filename,
        'linenumber': linenumber,
    }


def get_text(t):
    if t is not None:
        for i in t.block:
            if isinstance(i, renpy.ast.Say):
                return i.what

    return None


def count_missing(language, min_priority, max_priority, common_only):
    """
    Prints a count of missing translations for `language`.
    """

    translator = renpy.game.script.translator

    missing_translates = 0

    missing_items = []
    for filename in translate_list_files():
        for _, t in translator.file_translates[filename]:
            if (t.identifier, language) not in translator.language_translates:
                missing_translates += 1
                for i, n in enumerate(t.block):
                    missing_items.append(item_of(
                        identifier=t.identifier.replace('.', '_'),
                        language=language,
                        what=n.what,
                        who=n.who,
                        filename=t.filename,
                        linenumber=t.linenumber,
                    ))

    missing_strings = 0

    stl = renpy.game.script.translator.strings[language]  # @UndefinedVariable

    strings = renpy.translation.scanstrings.scan(min_priority, max_priority, common_only)

    missing_strings_items = []
    for s in strings:

        tlfn = translation_filename(s)

        if tlfn is None:
            continue

        if s.text in stl.translations:
            continue

        missing_strings += 1
        missing_strings_items.append(item_of(
            identifier=quote_unicode(s.text),
            language=language,
            what=quote_unicode(s.text),
            filename=elide_filename(s.filename),
            linenumber=s.line,
        ))

    message = "{}: {} missing dialogue translations, {} missing string translations.".format(
        language,
        missing_translates,
        missing_strings
    ),
    return message, {
        'dialogues': missing_items,
        'strings': missing_strings_items,
    }


def open_tl_file(fn):
    if fn in tl_file_cache:
        return tl_file_cache[fn]

    if not os.path.exists(fn):
        dn = os.path.dirname(fn)

        try:
            os.makedirs(dn)
        except Exception:
            pass

        f = open(fn, "a", encoding="utf-8")
        f.write(u"\ufeff")

    else:
        f = open(fn, "a", encoding="utf-8")

    f.write(projz_banner)

    f.write(u"\n")

    tl_file_cache[fn] = f

    return f


def get_translation(filename, language, all_strings):
    fn, common = shorten_filename(filename)

    # The common directory should not have dialogue in it.
    if common:
        return []

    raw_language = language
    if language == "None":
        language = None

    translator = renpy.game.script.translator

    item_list = []
    for label, t in translator.file_translates[filename]:
        identifier = t.identifier
        if not all_strings:
            if (t.identifier, language) in translator.language_translates:
                continue

            if hasattr(t, "alternate"):
                identifier = t.alternate
                if (t.alternate, language) in translator.language_translates:
                    continue

        for i, n in enumerate(t.block):
            item_list.append(item_of(
                identifier=identifier.replace('.', '_'),
                language=raw_language,
                what=n.what,
                new_text=get_text(translator.language_translates.get((t.identifier, language), None)),
                who=n.who,
                filename=t.filename,
                linenumber=t.linenumber,
            ))
    return item_list


def get_string_translation(language, filter, min_priority, max_priority, common_only, all_strings):
    """
    get strings to a list
    """
    if language == "None":
        stl = renpy.game.script.translator.strings[None]  # @UndefinedVariable
    else:
        stl = renpy.game.script.translator.strings[language]  # @UndefinedVariable

    # If this function changes, count_missing may also need to
    # change.

    strings = renpy.translation.scanstrings.scan(min_priority, max_priority, common_only)

    stringfiles = collections.defaultdict(list)

    for s in strings:

        tlfn = translation_filename(s)

        if tlfn is None:
            continue

        if not all_strings:
            # Already seen.
            if s.text in stl.translations:
                continue

        if language == "None" and tlfn == "common.rpy":
            tlfn = "common.rpym"

        stringfiles[tlfn].append(s)

    item_list = []
    for tlfn, sl in stringfiles.items():

        for s in sl:
            text = filter(s.text)

            item_list.append(item_of(
                identifier=quote_unicode(s.text),
                language=language,
                what=quote_unicode(text),
                new_text=stl.translations.get(s.text, None),
                filename=elide_filename(s.filename),
                linenumber=s.line,
            ))
    return item_list

tl_file_cache = { }
def open_tl_file(fn):

    if fn in tl_file_cache:
        return tl_file_cache[fn]

    if not os.path.exists(fn):
        dn = os.path.dirname(fn)

        try:
            os.makedirs(dn)
        except Exception:
            pass

        f = open(fn, "w", encoding="utf-8")
        f.write(u"\ufeff")

    else:
        f = open(fn, "w", encoding="utf-8")

    f.write(u"{}\n".format(projz_banner))

    f.write(u"\n")

    tl_file_cache[fn] = f

    return f

def close_tl_files():

    for i in tl_file_cache.values():
        i.close()

    tl_file_cache.clear()

def strip_line_breaks(text):
    return text.replace('\r\n', '').replace('\n', '')

def generate_translation(projz_translator, filename, language, filter, all_strings):
    fn, common = shorten_filename(filename)

    # The common directory should not have dialogue in it.
    if common:
        return { }

    tl_filename = os.path.join(renpy.config.gamedir, renpy.config.tl_directory, language, fn)

    raw_language = language
    if language == "None":
        language = None

    if tl_filename[-1] == "m":
        tl_filename = tl_filename[:-1]

    translator = renpy.game.script.translator

    missing_count = 0
    usage_count = 0
    for label, t in translator.file_translates[filename]:
        identifier = t.identifier.replace('.', '_')
        if not all_strings:
            if (t.identifier, language) in translator.language_translates:
                continue

            if hasattr(t, "alternate"):
                if (t.alternate, language) in translator.language_translates:
                    continue
        new_text = None
        if (identifier, language) in projz_translator:
            new_text = projz_translator[(identifier, language)]
        else:
            if hasattr(t, "alternate"):
                if (t.alternate, language) in projz_translator:
                    new_text = projz_translator[(t.alternate, language)]
        if new_text is None:
            missing_count += 1
            continue
        usage_count += 1

        # no line break
        new_text = strip_line_breaks(new_text)

        f = open_tl_file(tl_filename)

        f.write(u"# {}:{}\n".format(t.filename, t.linenumber))
        f.write(u"translate {} {}:\n".format(language, t.identifier.replace('.', '_')))
        f.write(u"\n")

        for n in t.block:
            f.write(u"    # " + n.get_code() + "\n")

        for n in t.block:
            # Only renpy.ast.Say
            if isinstance(n, renpy.ast.Say) and hasattr(n, 'what'):
                tmp_n = copy(n)
                setattr(tmp_n, 'what', new_text)
                n = tmp_n
            f.write(u"    " + n.get_code(filter) + "\n")

        f.write(u"\n")
    return {
        'missing_count':missing_count,
        'usage_count':usage_count
    }

def generate_string_translation(projz_translator, language, filter, min_priority, max_priority, common_only, all_strings): # @ReservedAssignment
    """
    Writes strings to the file.
    """

    if language == "None":
        stl = renpy.game.script.translator.strings[None] # @UndefinedVariable
    else:
        stl = renpy.game.script.translator.strings[language] # @UndefinedVariable

    # If this function changes, count_missing may also need to
    # change.

    strings = renpy.translation.scanstrings.scan(min_priority, max_priority, common_only)

    stringfiles = collections.defaultdict(list)

    for s in strings:

        tlfn = translation_filename(s)

        if tlfn is None:
            continue

        if not all_strings:
            # Already seen.
            if s.text in stl.translations:
                continue

        if language == "None" and tlfn == "common.rpy":
            tlfn = "common.rpym"

        stringfiles[tlfn].append(s)

    missing_count = 0
    usage_count = 0
    for tlfn, sl in stringfiles.items():

        # sl.sort(key=lambda s : (s.filename, s.line))

        f = None
        is_written = False
        for s in sl:
            # text = filter(s.text)
            key_text = quote_unicode(s.text)
            if (key_text, language) not in projz_translator:
                missing_count += 1
                continue
            usage_count += 1
            if is_written:
                # no line break
                new_text = strip_line_breaks(projz_translator[(key_text, language)])

                f.write(u"    # {}:{}\n".format(elide_filename(s.filename), s.line))
                f.write(u"    old \"{}\"\n".format(quote_unicode(s.text)))
                f.write(u"    new \"{}\"\n".format(quote_unicode(new_text)))
                f.write(u"\n")
            else:
                tlfn = os.path.join(renpy.config.gamedir, renpy.config.tl_directory, language, tlfn)
                f = open_tl_file(tlfn)

                f.write(u"translate {} strings:\n".format(language))
                f.write(u"\n")
                is_written = True

    return {
        'missing_count': missing_count,
        'usage_count': usage_count
    }

def generate(filter, max_priority):
    global proj_args

    json_data = read_json()
    dialogues_translator = {(i['identifier'], i['language']): i['new_text'] for i in json_data['items']['dialogues']}
    string_translator = {(i['identifier'], i['language']): i['new_text'] for i in json_data['items']['strings']}
    # print(dialogues_translator)
    # print(string_translator)

    dialogues_count = collections.defaultdict(int)
    string_count = collections.defaultdict(int)
    if not proj_args.strings_only:
        for filename in translate_list_files():
            res = generate_translation(dialogues_translator, filename, proj_args.language, filter, proj_args.all_strings)
            for k, v in res.items():
                dialogues_count[k] += v

    res = generate_string_translation(string_translator, proj_args.language, filter, proj_args.min_priority, max_priority, proj_args.common_only, proj_args.all_strings)
    for k, v in res.items():
        string_count[k] += v

    close_tl_files()

    if renpy.config.translate_launcher and (not proj_args.strings_only):
        src = os.path.join(renpy.config.renpy_base, "gui", "game", "script.rpy")
        dst = os.path.join(renpy.config.gamedir, "tl", proj_args.language, "script.rpym")

        if os.path.exists(src) and not os.path.exists(dst):
            shutil.copy(src, dst)

    return u'{}: dialogue translation: using {} and mising {}, string translation: using {} and mising {}'.format(
        proj_args.language, dialogues_count['usage_count'], dialogues_count['missing_count'],
        string_count['usage_count'], string_count['missing_count'])

def read_json():
    global proj_args
    with open(proj_args.file, 'r', encoding='utf-8') as f:
        json_data = json.load(f)
        if json_data['uuid'] != proj_args.uuid:
            raise ValueError('Expect uuid:{}, got {}'.format(proj_args.uuid, json_data['uuid']))
    return json_data


def write_json(items=None, message=None, ok=None):
    global proj_args
    with open(proj_args.file, 'w', encoding='utf-8') as f:
        f.write(json.dumps({
            'uuid': proj_args.uuid,
            'args': str(proj_args),
            'timestamp': time.time(),
            'items': items,
            'message': message,
            'ok': ok
        }, ensure_ascii=False, indent=2, encoding='utf-8'))


proj_args = None


def projz_inject_command():
    """
    The injection command. When called from the command line, this
    injects our code for extracting translations.
    """

    ap = renpy.arguments.ArgumentParser(description="Injection for extracting translations.")
    ap.add_argument("file", help="Json file to save")
    ap.add_argument("--uuid", help="The uuid to identify the json file generated by our code", required=True)
    ap.add_argument("--test-only", help="Test this command with doing anything", dest="test_only", action="store_true")
    ap.add_argument("--all-strings", help="Extract all strings, including translated ones",
                    dest="all_strings", action="store_true")
    ap.add_argument("--language", help="The language to generate translations for.", default="None")
    ap.add_argument("--rot13", help="Apply rot13 while generating translations.", dest="rot13", action="store_true")
    ap.add_argument("--piglatin", help="Apply pig latin while generating translations.", dest="piglatin",
                    action="store_true")
    ap.add_argument("--count", help="Instead of generating files, print a count of missing translations.", dest="count",
                    action="store_true")
    ap.add_argument("--generate", help="Generate translations with given input file.", dest="generate",
                    action="store_true")
    ap.add_argument("--min-priority", help="Translate strings with more than this priority.", dest="min_priority",
                    default=0, type=int)
    ap.add_argument("--max-priority", help="Translate strings with more than this priority.", dest="max_priority",
                    default=0, type=int)
    ap.add_argument("--strings-only", help="Only translate strings (not dialogue).", dest="strings_only", default=False,
                    action="store_true")
    ap.add_argument("--common-only", help="Only translate string from the common code.", dest="common_only",
                    default=False, action="store_true")

    args = ap.parse_args()
    global proj_args
    proj_args = args

    if args.test_only:
        write_json([], '', True)
        return False

    if renpy.config.translate_launcher:
        max_priority = args.max_priority or 499
    else:
        max_priority = args.max_priority or 299

    if args.count:
        msg, res = count_missing(args.language, args.min_priority, max_priority, args.common_only)
        write_json(res, msg, True)
        return False

    if args.rot13:
        filter = rot13_filter  # @ReservedAssignment
    elif args.piglatin:
        filter = piglatin_filter  # @ReservedAssignment
    else:
        filter = null_filter  # @ReservedAssignment

    if args.generate:
        msg = generate(filter, max_priority)
        write_json(message=msg, ok=True)
    else:
        dialogues = []
        if not args.strings_only:
            for filename in translate_list_files():
                dialogues += get_translation(filename, args.language, args.all_strings)
        strings = get_string_translation(args.language, filter, args.min_priority, max_priority,
                                         args.common_only, args.all_strings)
        write_json(
            {u'dialogues': dialogues, u'strings': strings},
            u'{}: {} dialogue translations found, {} string translations found'.format(args.language, len(dialogues),
                                                                                      len(strings)),
            True)
    return False


renpy.arguments.register_command("projz_inject_command", projz_inject_command)
